-- 시퀀스를 생성해보자
CREATE SEQUENCE SEQ1; --1부터 1씩 자동증가하는 시퀀스 객체가 생성

CREATE SEQUENCE SEQ2
START WITH 1
INCREMENT BY 1; --위와 동일

CREATE SEQUENCE SEQ3
START WITH 1
INCREMENT BY 1 NOCACHE; 

CREATE SEQUENCE SEQ4
START WITH 1
INCREMENT BY 1 
MAXVALUE 100 NOCACHE;

CREATE SEQUENCE SEQ5
START WITH 5
INCREMENT BY 5 
MAXVALUE 100 NOCACHE;

--시퀀스 정보 출력
SELECT *
FROM SEQ;

--시퀀스 값들을 발생시켜보자 한번 발생시킨 값은 두번다시 안나온다
SELECT
    SEQ1.NEXTVAL, SEQ2.NEXTVAL, SEQ3.NEXTVAL, SEQ4.NEXTVAL, SEQ5.NEXTVAL
FROM DUAL;

--시퀀스를 제거
DROP SEQUENCE SEQ1;
DROP SEQUENCE SEQ2;
DROP SEQUENCE SEQ3;
DROP SEQUENCE SEQ4;
DROP SEQUENCE SEQ5;

-- TABLE 생성
CREATE TABLE TEST1 (
    NUM NUMBER(3) PRIMARY KEY,
    NAME VARCHAR2(20) NOT NULL,
    TODAY DATE
);

--스키마의 이름과 널여부 유형 조회
DESC TEST1;

--데이터 추가
INSERT INTO TEST1 VALUES (1, 'CANDY', SYSDATE);

--PRIMARY KEY에 같은 값을 넣었을 때 어떤 오류가 나오는지 확인하기
INSERT INTO TEST1 VALUES (2, 'ROSE', SYSDATE); --정상적으로 입력
INSERT INTO TEST1 VALUES (2, 'BRUCE', SYSDATE); --기본키에서 앞의 2와 중복으로 오류
INSERT INTO TEST1 (NUM, TODAY) VALUES (2, SYSDATE); --오류발생 NULL 불가

-- 순서 바꿔서 세트로 입력
INSERT INTO TEST1 (NUM, TODAY, NAME) VALUES (3, '2024-11-20', 'MARY');

-- INSERT 를 2개 추가한 상태에서 ROLLBACK을 해보자
ROLLBACK; -- 마지막으로 커밋한 이후의 데이터는 모두 삭제됨

-- 다시 위의 INSERT문 실행해서 넣어보자
--넣은 후 커밋까지 해보자
INSERT INTO TEST1 VALUES (1, 'CANDY', SYSDATE);
INSERT INTO TEST1 VALUES (2, 'ROSE', SYSDATE); --정상적으로 입력
COMMIT;

-- 다시 롤백을 해보자
ROLLBACK;

--그리고 앞의 데이터가 삭제되었는지 데이터 조회
SELECT * FROM TEST1; -- 여전히 남아있다

--TEST2 테이블 생성
CREATE TABLE TEST2 (
    NUM NUMBER(3) CONSTRAINT PK_TEST2_NUM PRIMARY KEY,
    NAME VARCHAR2(20) CONSTRAINT NN_TEST2_NAME NOT NULL, --CONSTRAINT는 생략가능
    TODAY DATE
);

--TEST2에 데이터 삽입
INSERT INTO TEST2 VALUES (1, '이영자', SYSDATE); --정상적
INSERT INTO TEST2 VALUES (1, '김말자', SYSDATE); --오류발생

--데이터조회
SELECT *
FROM TEST2;

--테이블의 구조변경에서 ALTER TABLE을 사용함
-- 컬럼 추가 ADD / 컬럼 삭제 DROP CULUMN / 컬럼 수정 MODIFY 
--컬럼명 변경 RENAME COLUMN
--TEST1에 AGE NUMBER(3) 추가하기
ALTER TABLE TEST1
ADD AGE NUMBER(3);

--TEST1에 ADDR VARCHAR2(30) 추가하는데 기본값을 SEOUL로 추가하고 싶다
ALTER TABLE TEST1
ADD ADDR VARCHAR2(30)
DEFAULT 'SEOUL';

--TEST1에 GAIPDAY DATE로 추가하는데 기본값을 현재 날짜로
ALTER TABLE TEST1
ADD GAIPDAY DATE
DEFAULT SYSDATE;

--TEST1에 TODAY 컬럼 삭제하기
ALTER TABLE TEST1
DROP COLUMN TODAY;

--ADDR 컬럼의 크기를 30B에서 40B로 늘려보자
ALTER TABLE TEST1
MODIFY ADDR VARCHAR2(40);

--TEST1의 ADDR을 ADDRESS로 변경해보자
--RENAME COLUMN 컬럼명을 이용해서
ALTER TABLE TEST1
RENAME COLUMN ADDR TO ADDRESS;

--TEST1의 GAIPDAY를 WRITEDAY로 이름변경
ALTER TABLE TEST1
RENAME COLUMN GAIPDAY TO WRITEDAY;

-- TEST1 제약조건 중에서 SYS_C008317을 제거해보자
ALTER TABLE TEST1
DROP CONSTRAINT SYS_C008321;

-- TEST1의 제약조건을 추가하라
-- AGE의 범위가 10~30 사이로
-- 제약조건명: CK_TEST1_AGE
ALTER TABLE TEST1
ADD CONSTRAINT CK_TEST1_AGE
CHECK (AGE>=10 AND AGE<=30);

-- AGE에 범위를 벗어나게 추가해서 확인하기
INSERT INTO TEST1 (NUM, NAME, AGE) VALUES (3, 'SON', 34); --30 초과이므로 오류 

-- 1. TEST2에 BLOOD VARCHAR2(10) 초기값은 A로 추가하기
ALTER TABLE TEST2
ADD BLOOD VARCHAR2(10)
DEFAULT 'A';

-- 2. TEST2에서 TODAY 컬럼 제거하기
ALTER TABLE TEST2
DROP COLUMN TODAY; 

-- 3. TEST2의 NAME을 SAWON_NAME으로 컬럼 이름 변경
ALTER TABLE TEST2 
RENAME COLUMN NAME TO SAWON_NAME;

-- 4. BLOOD의 제약조건 추가(A, B, O, AB만 가능 CHECK) CK_TEST2_BLOOD
ALTER TABLE TEST2
ADD CONSTRAINT CK_TEST2_BLOOD       
CHECK (BLOOD IN ('A', 'B', 'O', 'AB'));

-- 5. NN_TEST2_NAME 이라는 제약조건을 제거하기
ALTER TABLE TEST2
DROP CONSTRAINT NN_TEST2_NAME;

--연습용 테이블 제거하기
DROP TABLE TEST1;
DROP TABLE TEST2;

--시퀀스 생성
CREATE SEQUENCE SEQ1 NOCACHE;

--테이블 생성
CREATE TABLE SAWON (
    NUM NUMBER(3) CONSTRAINT PK_SAWON_NUM PRIMARY KEY,
    NAME VARCHAR2(20),
    BUSEO VARCHAR2(20),
    GENDER VARCHAR2(10) DEFAULT '남자',
    AGE NUMBER(3),
    HEIGHT NUMBER(5,1), --소수점 이하 1자리 
    WRITEDAY DATE   
);

--제약조건 추가 : 부서 (홍보부, 교육부, 관리부) 만 가능하다
ALTER TABLE SAWON
ADD CONSTRAINT CK_SAWON_BUSEO
CHECK (BUSEO IN ('홍보부', '교육부', '관리부'));

--제약조건 추가 : 성별은 '남자', '여자' 만 가능하다
ALTER TABLE SAWON
ADD CONSTRAINT CK_SAWON_GENDER
CHECK (GENDER IN ('남자', '여자')); 

--데이터 추가
INSERT INTO SAWON VALUES (SEQ1.NEXTVAL, '이진','홍보부', '여자', 29, 167.9, SYSDATE);
INSERT INTO SAWON (NUM, NAME, BUSEO, AGE) VALUES (SEQ1.NEXTVAL, '강호동','관리부', 35);
INSERT INTO SAWON (NUM, NAME, BUSEO, HEIGHT) VALUES (SEQ1.NEXTVAL, '강호동','홍보부', 178.5);
INSERT INTO SAWON (NUM, NAME, BUSEO, GENDER, AGE, WRITEDAY)
VALUES (SEQ1.NEXTVAL, '이영자', '교육부', '여자', 42, SYSDATE);
COMMIT;

--수정
UPDATE SAWON SET HEIGHT=186.5; --WHERE 절을 안쓰면 전사적으로 업데이트가 된다 이는 문제

--다시 취소
ROLLBACK;

--NUM이 3인 경우만 수정
UPDATE SAWON SET HEIGHT=186.5
WHERE NUM = 3;

--여러 컬럼을 수정하는 경우
UPDATE SAWON
SET BUSEO='홍보부', AGE=39, HEIGHT=162.1 
WHERE NAME='이영자';

--WRITEDAY가 NULL일 경우 '2024-12-12'로 변경해보자
UPDATE SAWON SET WRITEDAY='2024-12-12' 
WHERE WRITEDAY IS NULL;

COMMIT;

-- DELETE DDL
DELETE FROM SAWON; -- 전체 필드값이 삭제됨

-- 다시 삭제 롤백
ROLLBACK;

-- AGE가 NULL인 데이터는 모두 삭제
DELETE FROM SAWON 
WHERE AGE IS NULL;

INSERT INTO SAWON VALUES (SEQ1.NEXTVAL, '김영희', '관리부', '여자', 45, 158.2, SYSDATE);

--GROUP BY 연습
-- 부서별 인원수와 평균 나이를 구하시오
SELECT BUSEO, COUNT(*), ROUND(AVG(AGE),0)
FROM SAWON
GROUP BY BUSEO;

-- 성별, 인원수, 평균 나이를 구하시오
SELECT GENDER, COUNT(*), ROUND(AVG(AGE),0)
FROM SAWON
GROUP BY GENDER;

-- JOIN 연습용 테이블 생성하기
CREATE TABLE FOOD (
    FOODNUM NUMBER(3) PRIMARY KEY,
    FOODNAME VARCHAR2(20),
    FOOPRICE NUMBER(7),
    FOODSIZE VARCHAR2(20)
);

CREATE TABLE BOOKING (
    BNUM NUMBER(3) CONSTRAINT PK_BOOKING_BNUM PRIMARY KEY,
    BNAME VARCHAR2(20) CONSTRAINT NN_BOOKING_BNAME NOT NULL,
    BHP VARCHAR2(20) CONSTRAINT UQ_BOOKING_BHP UNIQUE,
    FOODNUM NUMBER(3),
    BOOKINGDAY DATE,
    CONSTRAINT FK_FOODNUM
        FOREIGN KEY(FOODNUM)
        REFERENCES FOOD(FOODNUM)
);

--메뉴 등록
INSERT INTO FOOD VALUES (100, '자장면', 9000, '보통');
INSERT INTO FOOD VALUES (101, '자장면', 11000, '곱빼기');
INSERT INTO FOOD VALUES (200, '탕수육', 15000, '보통');
INSERT INTO FOOD VALUES (201, '탕수육', 20000, '곱빼기');
INSERT INTO FOOD VALUES (300, '칠리새우', 15000, '소');
INSERT INTO FOOD VALUES (301, '칠리새우', 30000, '대');
INSERT INTO FOOD VALUES (400, '해물짬뽕', 11000, '보통');
COMMIT;

-- 시퀀스 생성
CREATE SEQUENCE SEQ_FOOD START WITH 10 INCREMENT BY 10 NOCACHE;

-- 예약
INSERT INTO BOOKING VALUES (SEQ_FOOD.NEXTVAL, '이영자', '010-1234-5678',  200, '2024-12-24');
INSERT INTO BOOKING VALUES (SEQ_FOOD.NEXTVAL, '김말자', '010-7777-5678',  401, '2024-12-24'); --401은 FOOD에 없음
INSERT INTO BOOKING VALUES (SEQ_FOOD.NEXTVAL, '김말자', '010-7777-5678',  301, '2024-12-24');
INSERT INTO BOOKING VALUES (SEQ_FOOD.NEXTVAL, '이효리', '010-2323-5656',  400, '2024-12-24');
INSERT INTO BOOKING VALUES (SEQ_FOOD.NEXTVAL, '손예진', '010-7878-9999',  201, '2024-12-24');
COMMIT;

ALTER TABLE FOOD
RENAME COLUMN FOOPRICE TO FOODPRICE;

SELECT BNAME, BHP, F.FOODNAME, F.FOODPRICE, F.FOODSIZE, BOOKINGDAY
FROM FOOD F, BOOKING B
WHERE F.FOODNUM = B.FOODNUM;

--OUTER JOIN을 통해서 한번도 주문하지 않은 메뉴를 알아보자
SELECT F.FOODNUM, BNAME, FOODNAME, FOODPRICE, FOODSIZE
FROM FOOD F, BOOKING B
WHERE F.FOODNUM = B.FOODNUM(+); -- 아무도 주문하지 않은 메뉴는 주문자가 NULL이 나옮

SELECT F.FOODNUM, BNAME, FOODNAME, FOODPRICE, FOODSIZE
FROM FOOD F, BOOKING B
WHERE F.FOODNUM = B.FOODNUM(+)
    AND BNAME IS NULL;

--BOOKING에 추가된 메뉴를 FOOD에서 삭제할 수 있는가?
--자식 테이블 생성시 ON DELETE CASCADE 설정을 안했을시 못지운다
DELETE FROM FOOD
WHERE FOODNUM = 200; --200번 메뉴는 이영자가 에약주문함 그래서 삭제 못함

DELETE FROM FOOD
WHERE FOODNUM = 300; --아무도 300번 메뉴를 예약하지 않았으므로 삭제가능

DROP TABLE FOOD; --자식 테이블을 먼저 삭제해야 부모 테이블도 삭제가 가능

--BOOKING을 먼저 삭제하고 FOOD를 삭제해야함
DROP TABLE BOOKING;
DROP TABLE FOOD;
DROP TABLE SAWON;

DROP SEQUENCE SEQ_FOOD;
DROP SEQUENCE SEQ1;